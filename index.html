<!DOCTYPE html>
<meta charset="utf-8">
<html>
<title>Cables</title>

<style>

body
{
    background-color: 0xFF00FF;
    padding: 0;
    margin: 0;
    overflow: hidden;
}

div#viewport
{
    float: none;
    display:table-cell;
    vertical-align:middle;
    text-align: center;
}

div#searchBar
{
    width : 100%;
    height : 30px;
    background-color:  #91ADC7;
    padding-left: 10px;
    margin: 0;
    display: table;
}
div#searchBar div
{
    display: table-cell;
    vertical-align: middle;
}

iframe
{
    padding: 0;
    margin: 0;
    border: 0;
}

</style>

<!-- http://jquery.com/ -->
<script src="js/jquery-2.1.1.min.js"></script>
<!-- https://github.com/brandonaaron/jquery-mousewheel -->
<script src="js/jquery.mousewheel.min.js"></script>
<!-- https://github.com/alrusdi/jquery-plugin-query-object -->
<script src="js/jquery.query-object.min.js"></script>
<!-- http://threejs.org/ -->
<script src="js/three.min.js"></script>
<!-- https://github.com/ubilabs/kd-tree-javascript -->
<script src="js/kdTree.min.js"></script>
<!-- http://jsxgraph.uni-bayreuth.de/wp/2009/09/29/jsxcompressor-zlib-compressed-javascript-code/ -->
<script src="js/jsxcompressor.min.js" type="text/javascript"></script>
<!-- our data! -->
<!--<script src="points.js"></script>-->

<body>
    <div id="viewport">This visualization requires a browser that supports WebGL</div>
    <div id="searchBar"><div><span>Search by Cable REFID:</span><input type="text" size="40"/><span>Link to this view: </span><a id="link" href="index.html">index.html</a></div></div>
    <iframe id="wikileaks"></iframe>
    <script>

    var points =
    [
        {x : 0.54773998, y : 0.36280358, refid : "66BUENOSAIRES2481"},
        {x : 0.32983145, y : 0.32257608, refid : "72TEHRAN1164"},
        {x : 0.59436977, y : 0.63554692, refid : "72TEHRAN1381"},
        {x : 0.62918496, y : 0.54002303, refid : "72TEHRAN4789"},
        {x : 0.88092184, y : 0.63393712, refid : "72TEHRAN5055"},
        {x : 0.3885068, y : 0.3480961, refid : "73TEHRAN2077"},
        {x : 0.083759338, y : 0.34071726, refid : "73TEHRAN7005"},
        {x : 0.083533674, y : 0.34059808, refid : "73TEHRAN8233"},
        {x : 0.79695165, y : 0.49628136, refid : "75TEHRAN2069"},
        {x : 0.083533674, y : 0.34059808, refid : "7575LIBREVILLE1895"},
    ];

    // our currently selected cable document
    var currentDocument = null;
    var particleSize = 5;
    
    // setup our collision data structure
    var distance = function(a, b)
    {
      return Math.pow(a.x - b.x, 2) +  Math.pow(a.y - b.y, 2);
    }

    var tree = new kdTree(points, distance, ["x", "y"]);
    // construct our reverse lookup datastructure
    // will get populated futher down
    var refidToPoint = new Array();


    // setup our DOM elements

    var viewport = document.getElementById("viewport");
    viewport.style.width = window.innerWidth + "px";
    viewport.style.height = (window.innerHeight / 2) + "px";

    var searchBar = document.getElementById("searchBar");    
    var iframe = document.getElementById("wikileaks");
    var iframeWidth = viewport.clientWidth;
    var iframeHeight = window.innerHeight - viewport.clientHeight - searchBar.clientHeight;
    iframe.setAttribute("width", iframeWidth);
    iframe.setAttribute("height", iframeHeight);

    // setup rendering

    var viewportWidth = viewport.clientWidth;
    var viewportHeight = viewport.clientHeight;
    
    var aspectRatio = viewportWidth / viewportHeight;
    var scale = 5;

    var scene = new THREE.Scene();
    var camera = new THREE.OrthographicCamera( scale  / - 2, scale / 2, scale / aspectRatio / 2, scale / aspectRatio / - 2, 1, 1000 );

    // middle is in world coordinates
    var cameraLookAt = {x : 0, y : 0};
    var setViewport = function(middle)
    {
        camera.left = scale / -2 + middle.x;
        camera.right = scale / 2 + middle.x;
        camera.top = scale / aspectRatio / 2 + middle.y;
        camera.bottom = scale / aspectRatio / -2 + middle.y ;

        camera.updateProjectionMatrix();

        cameraLookAt = middle;

        url = "index.html?zoom=" + scale + "&x=" + middle.x + "&y=" + middle.y;

        link = document.getElementById("link");
        link.setAttribute("href", url);
        link.innerHTML = url;
    }

    // see if we got coordinates to zoom to

    {
        q_x = $.query.get("x");
        q_y = $.query.get("y");
        q_zoom = $.query.get("zoom");

        if(typeof(q_x) == "number" && typeof(q_y) == "number" && typeof(q_zoom) == "number")
        {
            scale = q_zoom;
            setViewport({x : q_x, y : q_y});
        }
        else
        {
            setViewport({x : 0.25, y : 0.4});        
        }
    }
    

    var renderer = new THREE.WebGLRenderer();

    viewport.innerHTML = "";


    renderer.setSize(viewportWidth, viewportHeight);
    renderer.setClearColor(0xF0F0F0, 1);

    // insert our canvas into the DOM and specify the sizes of our nodes
    viewport.appendChild(renderer.domElement);

    var geometry = new THREE.Geometry();

    for(k = 0; k < points.length; k++)
    {
        // fill our geometry buffer
        geometry.vertices.push(new THREE.Vector3(points[k].x, points[k].y, 0));
        // and construct our refidToPoint datastructur here
        refidToPoint[points[k].refid] = points[k];
    }

    var material = new THREE.ParticleSystemMaterial(
        {
            color : 0x91ADC7,
            size : particleSize,
            sizeAttenuation : false,
            blending: THREE.MultiplyBlending,
            transparent : true
        });
    var particleSystem = new THREE.ParticleSystem(geometry, material);
    

    scene.add(particleSystem);

    camera.position.z = 5;

    var render = function () 
    {
        renderer.render(scene, camera);
    };

    render();

    // set up our mouse events
    {
        canvas_node = document.getElementsByTagName("canvas")[0];

        mouseDown = false;
        moving = false;
        previousMouseLocation = {x : 0, y : 0};

        canvas_node.onmousedown = function(evt)
        {
            previousMouseLocation = {x : evt.clientX, y : evt.clientY};
            mouseDown = true;
        };

        canvas_node.onmouseup = function(evt)
        {
            if(currentDocument != null && moving == false)
            {
                iframe.src = "http://www.cablegatesearch.net/cable.php?id=" + currentDocument;
            }

            moving = false;
            mouseDown = false;

            document.body.style.cursor = 'default';
        };

        // either dragging the canvas, or searching for a point
        canvas_node.onmousemove = function(evt)
        {
            // return immediately if we didn't actually move
            if(previousMouseLocation.x == evt.clientX && previousMouseLocation.y == evt.clientY)
            {
                return;
            }

            // redefine the projection matrix and re-render
            if(mouseDown == true)
            {
                document.body.style.cursor = 'move';
                moving = true;

                delta = {x : (evt.clientX - previousMouseLocation.x) / viewportWidth, y : (evt.clientY - previousMouseLocation.y) / viewportHeight};
                delta.x *= scale;
                delta.y *= scale/aspectRatio;

                previousMouseLocation = {x : evt.clientX, y : evt.clientY};

                newLookAt = { x: cameraLookAt.x - delta.x, y : cameraLookAt.y + delta.y};
                setViewport(newLookAt);

                render();
            }
            // find the closest document to mouse cursor
            else
            {
                // convert our screen coordinates to world coordinates
                worldSpace = {x : 0, y : 0};
                worldSpace.x = camera.left + evt.clientX/viewportWidth * (camera.right - camera.left);
                worldSpace.y = camera.bottom + (viewportHeight - evt.clientY)/viewportHeight * (camera.top - camera.bottom);

                // find the point nearest our cursor
                var nearest = tree.nearest(worldSpace, 1);

                // convert its distance into screen coordinates
                distance = Math.sqrt(nearest[0][1]);
                distance *= viewportWidth / (camera.right - camera.left);

                // change our cursor to pointer to denote we can select a document
                if(distance <= particleSize)
                {
                    document.body.style.cursor = 'pointer';
                    // save off this refid for UI
                    currentDocument = nearest[0][0].refid;
                }
                else
                {
                    document.body.style.cursor = 'default';
                    currentDocument = null;
                }
            }
        };

        $("canvas").mousewheel(function(evt)
        {
            changeFactor = 1.3;

            if(evt.deltaY > 0)
            {
                scale /= changeFactor;
            }
            else if(evt.deltaY)
            {
                scale *= changeFactor;
            }

            // if we go to too small a scale, collision stops working as expected
            scale = Math.max(scale, 0.00001);

            // update our viewport with the new scale
            setViewport(cameraLookAt);

            render(); 
        })

        // setup our search functionality:
        input_node = document.getElementsByTagName("input")[0];
        input_node.oninput = function(evt)
        {
            cableName = evt.target.value;
            if(refidToPoint.hasOwnProperty(cableName))
            {
                pt = refidToPoint[cableName];

                setViewport(pt);

                render();
            }
        }
    }

    // finallyhandle query string
    
    </script>
</body>
</html>
